\section{Progettazione}
Lo sviluppo del progetto si è basato sul pattern \textbf{Model-View} di \textit{Qt} e metodologia mista \textit{top-down} e \textit{bottom-up}. \\
Oltre alla gerarchia, è stato realizzato un Container templatizzato per il contenimento degli oggetti appartenenti alla gerarchia.
Sono stati realizzati inoltre:
\begin{itemize}
  \item Una GUI (Graphical User Interface), basata su classi preesistenti di Qt;
  \item Un Model, il quale si occupa della gestione dei dati del programma, basato anch'esso su classi preesistenti di Qt;
  \item Un filter proxy, che funge da intermediario tra model e view e permette di filtrare i dati per la visualizzazione corretta su ogni tab;
  \item Una classe di Input/Output su file XML.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width = \linewidth]{img/diagramma}
  \caption{Diagramma delle classi di CrownSouls.}
\end{figure}

\subsection{Gerarchia}
La gerarchia è composta dalla classe base astratta \textit{InventoryItem}, dalla quale deriva \textbf{direttamente} la classe concreta \textit{Ring} e \textbf{virtualmente} le classi astratte \textit{Armor}, \textit{Weapon} e \textit{Shield}. Da queste tre classi derivano \textbf{singolarmente} e \textbf{direttamente} le tre rispettive classi concrete \textit{BodyArmor}, \textit{AttackWeapon} e \textit{DefenseShield}. Viene inoltre utilizzata l'\textit{ereditarietà multipla} per la definizione di classi che rappresentano oggetti appartenenti a più tipi; nello specifico, la classe \textit{WeaponArmor} deriva direttamente da \textit{Armor} e \textit{Weapon}, e la classe \textit{WeaponShield} deriva direttamente da \textit{Weapon} e \textit{Shield}. Questa forma di ereditarietà multipla è di tipo \textbf{is-a}, poiché un oggetto WeaponArmor è sia un oggetto Weapon che un oggetto Armor (e lo stesso vale per WeaponShield). Da queste due classi astratte derivano poi rispettivamente le classi concrete \textit{Gloves} e \textit{AttackShield}. \\
Ciascuna classe implementa dei metodi virtuali che riguardano l'impostazione e il recupero delle diverse proprietà degli elementi, e dei metodi virtuali specifici di ogni sottoclasse astratta per il calcolo e l'ottenimento di statistiche basate sulle proprietà. L'utilizzo del polimorfismo in tale contesto viene illustrato in seguito.

\subsection{Container}
È stata implementata una classe \textit{Inventory} che funge da container. La classe fornisce un template di smart pointer, e simula una lista singolarmente linkata con alcuni accorgimenti: a differenza di una lista singolarmente linkata standard, infatti, essa fornisce anche un puntatore all'ultimo elemento, e permette l'accesso diretto in sola lettura a un dato elemento tramite l'overloading dell'operatore accesso agli elementi del puntatore ([]). \\
La classe \textit{Inventory} contiene al suo interno due classi annidate:
\begin{itemize}
  \item La classe \textit{SmartP} rappresenta uno smart pointer; è infatti questa classe a rappresentare un elemento del container di tipo T templatizzato. Oltre al contenuto effettivo dell'elemento e al puntatore all'elemento successivo, la classe è fornita anche di:
  \begin{itemize}
    \item Costruttore e costruttore di copia profondo;
    \item Distruttore profondo;
    \item Assegnazione profonda;
    \item Overloading degli operatori dereferenziazione e accesso a membro;
    \item Overloading degli operatori booleani uguaglianza e disuguaglianza.
  \end{itemize}
  \item La classe \textit{Iterator} rappresenta l'iteratore del container. Nello specifico, un oggetto di classe Iterator è un iteratore costante, poiché non permette il side effect degli oggetti a cui punta. Questa classe presenta l'overloading dei seguenti operatori:
  \begin{itemize}
    \item Incremento prefisso;
    \item Dereferenziazione;
    \item Accesso a membro;
    \item Uguaglianza e disuguaglianza.
  \end{itemize}
\end{itemize}
La classe container fornisce diverse funzionalità di inserimento, cancellazione e ricerca; essa infatti permette:
\begin{itemize}
  \item L'inserimento e la rimozione di oggetti in testa, in coda o in una posizione data;
  \item La modifica di un oggetto a una posizione data (sovrascrittura);
  \item La lettura di oggetti in testa, in coda o a in una posizione data grazie all'overloading dell'operatore [].
\end{itemize}

\subsection{Modello}
Modello

\subsection{GUI}
GUI

\subsection{I/O}
Il programma permette la lettura e la scrittura di interi inventari. Questa possibilità è data dalla classe \textit{IO}, la quale fornisce i metodi necessari all'input e all'output dei dati tramite file .xml. Questi metodi risolvono il problema specifico del programma sviluppato, e non sono pertanto applicabili ad altri problemi.

\subsection{Polimorfismo}
Polimorfismo

\subsection{Scelte progettuali}
\begin{itemize}
\item Si è scelto di utilizzare una lista singolarmente linkata per la facilità e l'efficacia di questa struttura dati in un problema come quello in oggetto. Sono stati però seguiti degli accorgimenti per la semplificazione dell'accesso in sola lettura dati (tramite operatore []) e per la diminuzione dello sforzo computazionale. Un esempio di questo è la presenza di un puntatore all'ultimo elemento, che permette la riduzione di alcune operazioni, tra cui l'aggiunta e la rimozione in coda, da tempo O(n) a tempo costante;
\item Si è scelto di optare per una classe di Input/Output non scalabile per questioni di tempo. Una classe facilmente adattabile a più problemi, infatti, avrebbe richiesto uno studio più approfondito e un utilizzo pesante di polimorfismo sulla gerarchia; questo è certamente auspicabile, ma purtroppo incompatibile con le tempistiche reali del progetto.
\end{itemize}
